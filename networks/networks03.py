# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_netana_ex03.ipynb.

# %% auto 0
__all__ = ['plot_linregress_comparison', 'power_law', 'fit_degree_connectivity', 'categorize_assortativity',
           'randomize_and_measure', 'clustered_core_with_isolates']

# %% ../nbs/02_netana_ex03.ipynb 12
def plot_linregress_comparison(x, y, name, ax):
    log_x = np.log10(x)
    log_y = np.log10(y)
    res = stats.linregress(log_x, log_y)
    alpha = -res.slope
    
    
    ax.set_xscale('log')
    ax.set_yscale('log')
    ax.plot(x, y, 'o', label='Original data')
    ax.plot(x, 10**(res.slope * log_x + res.intercept), '--', label=f'Fit: y ~ x^-{alpha:.2f}')
    ax.set_xlabel('x')
    ax.set_ylabel(name)
    ax.set_title(f'Log-log plot of {name}')
    ax.legend()
    ax.grid(True)
    # Print results
    print(f"Estimated power-law exponent {name}: α ≈ {alpha:.2f}")
    print(f"R-squared {name}: {res.rvalue**2:.6f}")

# %% ../nbs/02_netana_ex03.ipynb 21
# quantify assortativity code
def power_law(x, a, b):
    return a * x ** b

# %% ../nbs/02_netana_ex03.ipynb 24
def fit_degree_connectivity(graph, title):
    # Step 1: Get average neighbor degrees
    adc = nx.average_degree_connectivity(graph)
    ks = np.array(list(adc.keys()))
    knn = np.array(list(adc.values()))

    # Step 2: Fit to power law
    popt, _ = curve_fit(power_law, ks, knn)
    a, mu = popt

    # Step 3: Plot
    plt.figure()
    plt.loglog(ks, knn, 'bo', label="avg degree connectivity")
    plt.loglog(ks, power_law(ks, *popt), 'r-', label=f"fit: $k^{{{mu:.2f}}}$")
    plt.xlabel("k (node degree)")
    plt.ylabel("k_nn(k) (avg neighbor degree)")
    plt.title(title)
    plt.legend()
    plt.grid(True)
    plt.show()

    return mu

# %% ../nbs/02_netana_ex03.ipynb 25
def categorize_assortativity(mu, name):
    category = ""
    if mu > 0:
        category = "assortative"
    if mu < 0:
        category = "disassortative"
    if abs(mu) < 0.001:
        category = "neutral"
    print(f"The calculated exponentv for {name}: {mu:.3f} shows a {category} degree correlation.")

# %% ../nbs/02_netana_ex03.ipynb 30
# randomizations
def randomize_and_measure(graph, n_iter=10):
    results = []
    for _ in range(n_iter):
        G_rand = graph.copy()
        nx.double_edge_swap(G_rand, nswap=10*G_rand.number_of_edges(), max_tries=100*G_rand.number_of_edges())
        p = nx.degree_pearson_correlation_coefficient(G_rand)
        results.append(p)
    return results


# %% ../nbs/02_netana_ex03.ipynb 36
def clustered_core_with_isolates(n=10, k=3):
    """
    Create a graph with a clique of size `k` and `n-k` isolated nodes.
    """
    G = nx.Graph()
    
    # Add clique nodes
    clique_nodes = range(k)
    G.add_nodes_from(clique_nodes)
    G.add_edges_from([(i, j) for i in clique_nodes for j in clique_nodes if i < j])
    
    # Add isolated nodes
    isolate_nodes = range(k, n)
    G.add_nodes_from(isolate_nodes)
    
    return G
